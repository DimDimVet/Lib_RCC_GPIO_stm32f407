#include "RCC_STM32F407.h"

/*-----------------------------------------------------------------------------------------------*/
RCC_Status_t RCC_Oscillator_Init(RCC_Oscillator_t *osc)
{
  uint32_t tick = 0;

  /*------------------------------- HSE Configuration ------------------------*/
  if ((osc->HSE_State == RCC_HSE_ON) || (osc->HSE_State == RCC_HSE_BYPASS))
    {
      /*Если используем BYPASS*/
      if (osc->HSE_State == RCC_HSE_BYPASS)
        {
          Enable_BIT(RCC->CR, RCC_CR_HSEBYP);/*включим BYPASS*/
          Enable_BIT(RCC->CR, RCC_CR_HSEON);/*включим HSE*/
        }

      Enable_BIT(RCC->CR, RCC_CR_HSEON);/*включим HSE*/

      /* Проверка состояния HSE */
      if ((osc->HSE_State) != RCC_HSE_OFF)
        {
          /* Подождите, пока HSE будет готова */
          tick = 0;

          while (Read_BIT(RCC->CR, RCC_CR_HSERDY) == 0)
            {
              tick++;

              if (tick > 25000)
                {
                  return RCC_Error_Time;
                }
            }
        }
    }

  else
    {
      Disable_BIT(RCC->CR, RCC_CR_HSEON);/*отключим HSE*/
      Disable_BIT(RCC->CR, RCC_CR_HSEBYP);/*отключим BYPASS*/
    }

  /*----------------------------- HSI Configuration --------------------------*/
  if (osc->HSI_State == RCC_HSI_ON)
    {
      /*Установим калибровку */
      if (osc->HSI_CalibrationValue == 0)
        {
          osc->HSI_CalibrationValue = 10U;//10U - калибровка в дефолте,0 and 0x1F
        }

      if (osc->HSI_CalibrationValue != 0)
        {
          Modify_REG(RCC->CR, RCC_CR_HSITRIM, osc->HSI_CalibrationValue << RCC_CR_HSITRIM_Pos);
        }

      Enable_BIT(RCC->CR, RCC_CR_HSION);/*включим HSI*/

      /* Подождите, пока HSI будет готова */
      tick = 0;

      while (Read_BIT(RCC->CR, RCC_CR_HSIRDY) == 0)
        {
          tick++;

          if (tick > 25000)
            {
              return RCC_Error_Time;
            }
        }
    }
  else
    {
      Disable_BIT(RCC->CR, RCC_CR_HSION);/*отключим HSI*/
    }

  /*------------------------------ LSI Configuration -------------------------*/
  if (osc->LSI_State == RCC_LSI_ON)
    {

      Enable_BIT(RCC->CSR, RCC_CSR_LSION);/*включим LSI*/

      /* Подождите, пока LSI будет готова */
      tick = 0;

      while (Read_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0)
        {
          tick++;

          if (tick > 45000)
            {
              return RCC_Error_Time;
            }
        }
    }
  else
    {
      Disable_BIT(RCC->CSR, RCC_CSR_LSION);/*отключим LSI*/
    }

  /*------------------------------ LSE Configuration -------------------------*/
  if ((osc->LSE_State == RCC_LSE_ON) || (osc->LSE_State == RCC_LSE_BYPASS))
    {
      Enable_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);
      Enable_BIT(PWR->CR, PWR_CR_DBP);

      /*Если используем BYPASS*/
      if (osc->LSE_State == RCC_LSE_BYPASS)
        {
          Enable_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);/*включим BYPASS*/
          Enable_BIT(RCC->BDCR, RCC_BDCR_LSEON);/*включим LSE*/
        }

      Enable_BIT(RCC->BDCR, RCC_BDCR_LSEON);/*включим LSE*/

      /* Проверка состояния LSE */
      if ((osc->LSE_State) != RCC_LSE_OFF)
        {
          /* Подождите, пока LSE будет готова */
          tick = 0;

          while (Read_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0)
            {
              tick++;

              if (tick > 45000)
                {
                  return RCC_Error_Time;
                }
            }
        }

      Disable_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);
    }

  else
    {
      Disable_BIT(RCC->BDCR, RCC_BDCR_LSEON);/*отключим LSE*/
      Disable_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);/*отключим BYPASS*/
    }

  return RCC_Ok;
}

/*-----------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------*/
RCC_Status_t RCC_PLL_Init(RCC_PLL_t *pll)
{
  if (pll->PLL_State == RCC_PLL_ON)
    {
      uint32_t tick = 0;

      Disable_BIT(RCC->CR, RCC_CR_PLLON);/*отключим PLL для настроек*/

      /*подождем отключение PLL*/
      while (Read_BIT(RCC->CR, RCC_CR_PLLRDY) == 1)
        {
          tick++;

          if (tick > 20000)
            {
              return RCC_Error_Time;
            }
        }

      /*проверим структуру на 0 заполнение*/
      if (pll->PLL_M == 0)
        {
          pll->PLL_M = 2;
        }

      if (pll->PLL_N == 0)
        {
          pll->PLL_M = 50;
        }

      if (pll->PLL_P == 0)
        {
          pll->PLL_P = 2;
        }

      if (pll->PLL_Q == 0)
        {
          pll->PLL_Q = 2;
        }

      /*пишем в регистр*/
      Write_REG(RCC->PLLCFGR, (pll->PLL_Sourse | pll->PLL_M | (pll->PLL_N << RCC_PLLCFGR_PLLN_Pos) | (((pll->PLL_P >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) | (pll->PLL_Q << RCC_PLLCFGR_PLLQ_Pos));

      Enable_BIT(RCC->CR, RCC_CR_PLLON);/*включим PLL*/

      /*подождем включение PLL*/
      while (Read_BIT(RCC->CR, RCC_CR_PLLRDY) == 0)
        {
          tick++;

          if (tick > 20000)
            {
              return RCC_Error_Time;
            }
        }
    }

  return RCC_Ok;
}
/*-----------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------*/
RCC_Status_t RCC_AHB_Init(RCC_AHB_t *ahb)
{
	uint32_t tick = 0;
	
	if(ahb->SYSCLK_Sourse == RCC_SYSCLK_SOURCE_HSI)
	{
		Write_REG(RCC->CFGR,RCC_SYSCLK_SOURCE_HSI);
		
		 while (Read_BIT(RCC->CFGR, RCC_CFGR_SWS_HSI) == 0)
        {
          tick++;

          if (tick > 20000)
            {
              return RCC_Error_Time;
            }
        }
	}
	else if(ahb->SYSCLK_Sourse == RCC_SYSCLK_SOURCE_HSE)
	{
		Write_REG(RCC->CFGR,RCC_SYSCLK_SOURCE_HSE);
		
				 while (Read_BIT(RCC->CFGR, RCC_CFGR_SWS_HSE) == 0)
        {
          tick++;

          if (tick > 20000)
            {
              return RCC_Error_Time;
            }
        }
	}
	else if(ahb->SYSCLK_Sourse == RCC_SYSCLK_SOURCE_PLL)
	{
		Write_REG(RCC->CFGR,RCC_SYSCLK_SOURCE_PLL);
		
				 while (Read_BIT(RCC->CFGR, RCC_CFGR_SWS_PLL) == 0)
        {
          tick++;

          if (tick > 20000)
            {
              return RCC_Error_Time;
            }
        }
	}
	
	
	return RCC_Ok;
}
